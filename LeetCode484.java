package com.tuhailong.leetcode.greedy;

/**
 * 现在给定一个只由字符 'D' 和 'I' 组成的 秘密签名。
 * 'D' 表示两个数字间的递减关系，'I' 表示两个数字间的递增关系。
 * 并且 秘密签名 是由一个特定的整数数组生成的，该数组唯一地包含 1 到 n 中所有不同的数字
 * （秘密签名的长度加 1 等于 n）。
 * 例如，秘密签名 "DI" 可以由数组 [2,1,3] 或 [3,1,2] 生成，
 * 但是不能由数组 [3,2,4] 或 [2,1,3,4] 生成，因为它们都不是合法的能代表 "DI" 秘密签名 的特定串。
 * 现在你的任务是找到具有最小字典序的 [1, 2, ... n] 的排列，使其能代表输入的 秘密签名。
 * 示例 1：
 * 输入： "I"
 * 输出： [1,2]
 * 解释： [1,2] 是唯一合法的可以生成秘密签名 "I" 的特定串，数字 1 和 2 构成递增关系。
 * 示例 2：
 * 输入： "DI"
 * 输出： [2,1,3]
 * 解释： [2,1,3] 和 [3,1,2] 可以生成秘密签名 "DI"，
 * 但是由于我们要找字典序最小的排列，因此你需要输出 [2,1,3]。
 * 注：
 * 输出字符串只会包含字符 'D' 和 'I'。
 * 输入字符串的长度是一个正整数且不会超过 10,000。
 * 链接：https://leetcode-cn.com/problems/find-permutation
 *
 * @author tuhailong
 * @since 2019-11-23
 */
class LeetCode484 {
    /**
     * 解题思路：贪心算法
     *  从头开始考虑这个秘密签名：
     *  如果秘密以若干个 I 开头，那么我们从小到大依次填入数，这样可以满足 I 的条件，并且显然这样做字典序是最小的；
     *  如果秘密以若干个 D 开头，假设有 k 个 D，那么第一个数至少为 k + 1，即按照 k + 1, k, k - 1, ..., 2, 1 的顺序填入 k + 1 个数，
     *  满足 k 个 D 的条件，并且字典序是最小的。
     *  无论秘密以 I 或 D 开头，都填了从 1 开始的若干个数，因此在处理完这些 I 或 D 之后，剩下的数仍然是一个连续的区间。
     *  如果秘密接着出现了若干个 I，仍然可以从小到大依次填入剩余的数；
     *  如果出现了 k 个 D，我们也可以从剩余的数中选出 k 个最小的，从大到小依次填入这些数。
     *  如果出现了连续的 I，我们会顺序填入数；如果出现了 D，我们会逆序填入数。
     *  因此可以先将所有的数从小到大依次填入，组成 [1 .. n] 的排列，随后对于秘密中连续的 D，我们将对应位置的区间进行翻转即可。
     */
    public int[] findPermutation(String s) {
        char[] chs = s.toCharArray();
        int[] ans = new int[chs.length + 1];
        for (int i = 0; i < ans.length; i++) {
            ans[i] = i + 1;
        }
        int i = 1;
        while (i <= chs.length) {
            int j = i;
            while (i <= chs.length && chs[i - 1] == 'D') {
                ++i;
            }
            reverse(ans, j - 1, i);
            i++;
        }
        return ans;
    }

    private void reverse(int[] nums, int lid, int rid) {
        for (int i = 0; i < (rid - lid) / 2; i++) {
            nums[i + lid] ^= nums[rid - i - 1];
            nums[rid - i - 1] ^= nums[i + lid];
            nums[i + lid] ^= nums[rid - i - 1];
        }
    }
}
